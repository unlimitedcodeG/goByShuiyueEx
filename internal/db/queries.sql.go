// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddPostTag = `-- name: AddPostTag :exec
INSERT INTO post_tags (post_id, tag_id) VALUES ($1, $2)
`

type AddPostTagParams struct {
	PostID int64 `json:"post_id"`
	TagID  int64 `json:"tag_id"`
}

// AddPostTag
//
//	INSERT INTO post_tags (post_id, tag_id) VALUES ($1, $2)
func (q *Queries) AddPostTag(ctx context.Context, arg AddPostTagParams) error {
	_, err := q.db.Exec(ctx, AddPostTag, arg.PostID, arg.TagID)
	return err
}

const CreatePost = `-- name: CreatePost :one
INSERT INTO posts (
    title, content, author_id, status
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, title, content, author_id, status, created_at, updated_at
`

type CreatePostParams struct {
	Title    string         `json:"title"`
	Content  string         `json:"content"`
	AuthorID int64          `json:"author_id"`
	Status   NullPostStatus `json:"status"`
}

// CreatePost
//
//	INSERT INTO posts (
//	    title, content, author_id, status
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, title, content, author_id, status, created_at, updated_at
func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Posts, error) {
	row := q.db.QueryRow(ctx, CreatePost,
		arg.Title,
		arg.Content,
		arg.AuthorID,
		arg.Status,
	)
	var i Posts
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateTag = `-- name: CreateTag :one
INSERT INTO tags (name) VALUES ($1)
RETURNING id, name, created_at
`

// CreateTag
//
//	INSERT INTO tags (name) VALUES ($1)
//	RETURNING id, name, created_at
func (q *Queries) CreateTag(ctx context.Context, name string) (Tags, error) {
	row := q.db.QueryRow(ctx, CreateTag, name)
	var i Tags
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (
    username, email, password_hash, full_name
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, username, email, password_hash, full_name, created_at, updated_at
`

type CreateUserParams struct {
	Username     string      `json:"username"`
	Email        string      `json:"email"`
	PasswordHash string      `json:"password_hash"`
	FullName     pgtype.Text `json:"full_name"`
}

// CreateUser
//
//	INSERT INTO users (
//	    username, email, password_hash, full_name
//	) VALUES (
//	    $1, $2, $3, $4
//	)
//	RETURNING id, username, email, password_hash, full_name, created_at, updated_at
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, CreateUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeletePost = `-- name: DeletePost :exec
DELETE FROM posts
WHERE id = $1 AND author_id = $2
`

type DeletePostParams struct {
	ID       int64 `json:"id"`
	AuthorID int64 `json:"author_id"`
}

// DeletePost
//
//	DELETE FROM posts
//	WHERE id = $1 AND author_id = $2
func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) error {
	_, err := q.db.Exec(ctx, DeletePost, arg.ID, arg.AuthorID)
	return err
}

const DeleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

// DeleteTag
//
//	DELETE FROM tags
//	WHERE id = $1
func (q *Queries) DeleteTag(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeleteTag, id)
	return err
}

const DeleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

// DeleteUser
//
//	DELETE FROM users
//	WHERE id = $1
func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeleteUser, id)
	return err
}

const GetPost = `-- name: GetPost :one
SELECT p.id, p.title, p.content, p.author_id, p.status, p.created_at, p.updated_at,
       u.username as author_username
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.id = $1 LIMIT 1
`

type GetPostRow struct {
	ID             int64          `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	AuthorID       int64          `json:"author_id"`
	Status         NullPostStatus `json:"status"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	AuthorUsername string         `json:"author_username"`
}

// GetPost
//
//	SELECT p.id, p.title, p.content, p.author_id, p.status, p.created_at, p.updated_at,
//	       u.username as author_username
//	FROM posts p
//	JOIN users u ON p.author_id = u.id
//	WHERE p.id = $1 LIMIT 1
func (q *Queries) GetPost(ctx context.Context, id int64) (GetPostRow, error) {
	row := q.db.QueryRow(ctx, GetPost, id)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorUsername,
	)
	return i, err
}

const GetPostTags = `-- name: GetPostTags :many
SELECT t.id, t.name, t.created_at
FROM tags t
JOIN post_tags pt ON t.id = pt.tag_id
WHERE pt.post_id = $1
ORDER BY t.name
`

// GetPostTags
//
//	SELECT t.id, t.name, t.created_at
//	FROM tags t
//	JOIN post_tags pt ON t.id = pt.tag_id
//	WHERE pt.post_id = $1
//	ORDER BY t.name
func (q *Queries) GetPostTags(ctx context.Context, postID int64) ([]Tags, error) {
	rows, err := q.db.Query(ctx, GetPostTags, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tags{}
	for rows.Next() {
		var i Tags
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPostsByTag = `-- name: GetPostsByTag :many
SELECT p.id, p.title, p.content, p.author_id, p.status, p.created_at, p.updated_at
FROM posts p
JOIN post_tags pt ON p.id = pt.post_id
WHERE pt.tag_id = $1 AND p.status = 'published'
ORDER BY p.created_at DESC
`

// GetPostsByTag
//
//	SELECT p.id, p.title, p.content, p.author_id, p.status, p.created_at, p.updated_at
//	FROM posts p
//	JOIN post_tags pt ON p.id = pt.post_id
//	WHERE pt.tag_id = $1 AND p.status = 'published'
//	ORDER BY p.created_at DESC
func (q *Queries) GetPostsByTag(ctx context.Context, tagID int64) ([]Posts, error) {
	rows, err := q.db.Query(ctx, GetPostsByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Posts{}
	for rows.Next() {
		var i Posts
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTag = `-- name: GetTag :one
SELECT id, name, created_at
FROM tags
WHERE id = $1 LIMIT 1
`

// GetTag
//
//	SELECT id, name, created_at
//	FROM tags
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetTag(ctx context.Context, id int64) (Tags, error) {
	row := q.db.QueryRow(ctx, GetTag, id)
	var i Tags
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const GetTagByName = `-- name: GetTagByName :one
SELECT id, name, created_at
FROM tags
WHERE name = $1 LIMIT 1
`

// GetTagByName
//
//	SELECT id, name, created_at
//	FROM tags
//	WHERE name = $1 LIMIT 1
func (q *Queries) GetTagByName(ctx context.Context, name string) (Tags, error) {
	row := q.db.QueryRow(ctx, GetTagByName, name)
	var i Tags
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const GetUser = `-- name: GetUser :one
SELECT id, username, email, password_hash, full_name, created_at, updated_at
FROM users
WHERE id = $1 LIMIT 1
`

// GetUser
//
//	SELECT id, username, email, password_hash, full_name, created_at, updated_at
//	FROM users
//	WHERE id = $1 LIMIT 1
func (q *Queries) GetUser(ctx context.Context, id int64) (Users, error) {
	row := q.db.QueryRow(ctx, GetUser, id)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, full_name, created_at, updated_at
FROM users
WHERE email = $1 LIMIT 1
`

// GetUserByEmail
//
//	SELECT id, username, email, password_hash, full_name, created_at, updated_at
//	FROM users
//	WHERE email = $1 LIMIT 1
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRow(ctx, GetUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, full_name, created_at, updated_at
FROM users
WHERE username = $1 LIMIT 1
`

// GetUserByUsername
//
//	SELECT id, username, email, password_hash, full_name, created_at, updated_at
//	FROM users
//	WHERE username = $1 LIMIT 1
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (Users, error) {
	row := q.db.QueryRow(ctx, GetUserByUsername, username)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListPosts = `-- name: ListPosts :many
SELECT p.id, p.title, p.content, p.author_id, p.status, p.created_at, p.updated_at,
       u.username as author_username
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.status = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListPostsParams struct {
	Status NullPostStatus `json:"status"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

type ListPostsRow struct {
	ID             int64          `json:"id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	AuthorID       int64          `json:"author_id"`
	Status         NullPostStatus `json:"status"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	AuthorUsername string         `json:"author_username"`
}

// ListPosts
//
//	SELECT p.id, p.title, p.content, p.author_id, p.status, p.created_at, p.updated_at,
//	       u.username as author_username
//	FROM posts p
//	JOIN users u ON p.author_id = u.id
//	WHERE p.status = $1
//	ORDER BY p.created_at DESC
//	LIMIT $2 OFFSET $3
func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.Query(ctx, ListPosts, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsRow{}
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPostsByAuthor = `-- name: ListPostsByAuthor :many
SELECT id, title, content, author_id, status, created_at, updated_at
FROM posts
WHERE author_id = $1
ORDER BY created_at DESC
`

// ListPostsByAuthor
//
//	SELECT id, title, content, author_id, status, created_at, updated_at
//	FROM posts
//	WHERE author_id = $1
//	ORDER BY created_at DESC
func (q *Queries) ListPostsByAuthor(ctx context.Context, authorID int64) ([]Posts, error) {
	rows, err := q.db.Query(ctx, ListPostsByAuthor, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Posts{}
	for rows.Next() {
		var i Posts
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.AuthorID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTags = `-- name: ListTags :many
SELECT id, name, created_at
FROM tags
ORDER BY name
`

// ListTags
//
//	SELECT id, name, created_at
//	FROM tags
//	ORDER BY name
func (q *Queries) ListTags(ctx context.Context) ([]Tags, error) {
	rows, err := q.db.Query(ctx, ListTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tags{}
	for rows.Next() {
		var i Tags
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsers = `-- name: ListUsers :many
SELECT id, username, email, full_name, created_at, updated_at
FROM users
ORDER BY created_at DESC
`

type ListUsersRow struct {
	ID        int64       `json:"id"`
	Username  string      `json:"username"`
	Email     string      `json:"email"`
	FullName  pgtype.Text `json:"full_name"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

// ListUsers
//
//	SELECT id, username, email, full_name, created_at, updated_at
//	FROM users
//	ORDER BY created_at DESC
func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, ListUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemovePostTag = `-- name: RemovePostTag :exec
DELETE FROM post_tags
WHERE post_id = $1 AND tag_id = $2
`

type RemovePostTagParams struct {
	PostID int64 `json:"post_id"`
	TagID  int64 `json:"tag_id"`
}

// RemovePostTag
//
//	DELETE FROM post_tags
//	WHERE post_id = $1 AND tag_id = $2
func (q *Queries) RemovePostTag(ctx context.Context, arg RemovePostTagParams) error {
	_, err := q.db.Exec(ctx, RemovePostTag, arg.PostID, arg.TagID)
	return err
}

const UpdatePost = `-- name: UpdatePost :one
UPDATE posts
SET 
    title = $3,
    content = $4,
    status = $5
WHERE id = $1 AND author_id = $2
RETURNING id, title, content, author_id, status, created_at, updated_at
`

type UpdatePostParams struct {
	ID       int64          `json:"id"`
	AuthorID int64          `json:"author_id"`
	Title    string         `json:"title"`
	Content  string         `json:"content"`
	Status   NullPostStatus `json:"status"`
}

// UpdatePost
//
//	UPDATE posts
//	SET
//	    title = $3,
//	    content = $4,
//	    status = $5
//	WHERE id = $1 AND author_id = $2
//	RETURNING id, title, content, author_id, status, created_at, updated_at
func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Posts, error) {
	row := q.db.QueryRow(ctx, UpdatePost,
		arg.ID,
		arg.AuthorID,
		arg.Title,
		arg.Content,
		arg.Status,
	)
	var i Posts
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.AuthorID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    username = $2,
    email = $3,
    full_name = $4
WHERE id = $1
RETURNING id, username, email, password_hash, full_name, created_at, updated_at
`

type UpdateUserParams struct {
	ID       int64       `json:"id"`
	Username string      `json:"username"`
	Email    string      `json:"email"`
	FullName pgtype.Text `json:"full_name"`
}

// UpdateUser
//
//	UPDATE users
//	SET
//	    username = $2,
//	    email = $3,
//	    full_name = $4
//	WHERE id = $1
//	RETURNING id, username, email, password_hash, full_name, created_at, updated_at
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, UpdateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FullName,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
